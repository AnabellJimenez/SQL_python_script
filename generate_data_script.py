'''Python script to generate data for the fertility app simulation/functional testing'''
import sqlite3
import random
import time
from Database_model import Database
import datetime
from datetime import timedelta
from random import randint



db = Database("fertility")

'''function generates number of users entered'''
def create_users():
	num = int(raw_input("Enter number of users to generate: "))

	for i in range(0,num):
		first_name = "Anabell" + str(i)
		last_name = "Jimenez" + str(i)
		db.create_user(first_name,last_name,random.randint(18,50))

# db.print_read(db.read_table())

'''function generates a date list using datetime phython function and backdates based on number of days passed in as a parameter '''
def generate_dates(numdays):
	base  = datetime.datetime.today()
	date_list = [base  - datetime.timedelta(days=x)  for x in range(0, numdays)]
	
	return date_list
# def generate_dates_modified(numdays)

# print generate_dates(4)
def get_users():
	user_list = db.get_user_list()	
	return user_list

''' function uses Database class from Database_model to create user information in the SQL database'''
def generate_info():
	#the date range is defined when running the script in raw_input
	date_list = generate_dates(int(raw_input("Enter a number for date range: ")))

	#User list is generated by accessing the database user table
	user_list = get_users()

	#The script is hardcoded to generate weight ranges for 4 users
	weights = {1 : randint(123,128), 2:randint(150,155), 3: randint(100,105), 4:randint(130,138)}

	#date format is not optimal for the graphing so parsed date and made new list
	parsed_dates = []
	for date in date_list:
		parsed_dates.append(date.strftime("%Y-%m-%d"))
	# print parsed_dates

	#Generates data for every user within the date range, a value of 0 is equivalent to no entry selected, each integer corresponds to a user input
	for date in parsed_dates:
		#Access the user's weight range and use a randint to get a random weight within the range
		for user in user_list:
			if weights.has_key(user[0]):
				weight = weights[user[0]]

			#Enter data in all tables for the user on the specific date
			db.log_in(user[0], date)
			db.mood(user[0],date,random.randint(1,21) )
			db.mood(user[0],date,random.randint(0,21) )
			db.symptoms(user[0], date, randint(0,10)),
			db.intercourse(user[0], date, randint(0,2))
			db.activity(user[0], date, randint(1500, 15000), randint(0,15))
			db.nutrition(user[0], date, randint(1,8), randint(1,8))
			db.ovulation_test(user[0], date, randint(0,2))
			db.pregnancy_test(user[0], date, randint(0,2))
			db.sleep(user[0], date, randint(0,8))
			db.symptoms(user[0], date, randint(0,29))
			db.symptoms(user[0], date, randint(0,29))
			db.weight(user[0], date, weight)
			# weight and period need to be done separately


'''function simulates a woman's menstrual cycle for a date range in days passed in as the paramter and a user, 
this was left to input manually because I wanted to vary the user's cycles to show regular and irregular cycles'''
def menstrual_cycle(user, days):
	base = datetime.datetime.today()
	final_date =  base - datetime.timedelta(days)
	next_date = final_date - datetime.timedelta(2)

	# while in range of a year
	while next_date  < base:
		# pick a day within a range (+/- 3 days)
		next_date = next_date + datetime.timedelta(randint(1,3))
		p_days = randint(4,6)
		db.period(user, next_date.strftime("%Y-%m-%d"), 2)
		#enter period for (+/- 1 days)
		for i in range(1, p_days):
			day = next_date + datetime.timedelta(i)
			db.period(user, day.strftime("%Y-%m-%d"), 2)
			# add 28 (+/- 1-7 days)
		next_date = next_date  + datetime.timedelta(randint(26,29))
		# print "next expected period: ", str(next_date), "\n"
		# loop again

'''functions calls for generating data:
menstrual cycle - 4 users, changed data and ranges to get regular and irregular cycles'''
# menstrual_cycle(1, 400)
# generate_info()
# db.print_read(db.read_table())
# create_users()

